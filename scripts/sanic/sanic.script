local mod_ground_mode = require "scripts.shared.ground_mode"
local mod_sensor_helper = require "scripts.shared.sensor_helper"
local mod_utils = require "scripts.shared.utils"
local mod_tile_helper = require "scripts.shared.tile_helper"

local mod_sanic_state = require "scripts.sanic.sanic_state"

local SPRITE_ANGLES = 8
local RAD_2_SPRITE_ANGLE = (2*math.pi)/SPRITE_ANGLES
local SPRITE_ANGLE_2_RAD = SPRITE_ANGLES/(2*math.pi)

local PER_FRAME_2_PER_SECOND = 60

local ACCEL_GROUND = PER_FRAME_2_PER_SECOND*0.046875
local ACCEL_AIR = PER_FRAME_2_PER_SECOND*0.046875

local DECEL_GROUND_RUN = PER_FRAME_2_PER_SECOND*0.5
local FRICTION_GROUND_RUN = PER_FRAME_2_PER_SECOND*0.046875

local DECEL_GROUND_ROLL = PER_FRAME_2_PER_SECOND*0.125
local FRICTION_GROUND_ROLL = FRICTION_GROUND_RUN*0.5

local TOP_SPEED_GROUND_RUN = PER_FRAME_2_PER_SECOND*6
local TOP_SPEED_GROUND_ROLL = PER_FRAME_2_PER_SECOND*16
local TOP_SPEED_AIR_Y = 16

local MIN_ROLLING_GSP = 0.53125

local GRAVITY_AIR = -0.21875

local JUMP_INITIAL_SPEED = 5

local TILEMAP_URL = "/level#tilemap"

local TILE_DATA_PATH = "/resources/tiles/tile_black.json"

function load_tile_data(filename)
	local filedata = sys.load_resource(filename)
	local json_data = json.decode(filedata)

	return json_data.tile_data
end

local TILE_DATA = load_tile_data(TILE_DATA_PATH)

local TILE_DATA_D =	{
							{solid = true, angle = 0, heightmap = {{6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5}, {16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16}, {}, {16,16,16,16,16,8,0,0,0,0,0,0,0,0,0,0}}},
							{solid = true, angle = 0, heightmap = {{5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6}, {16,16,16,16,16,8,0,0,0,0,0,0,0,0,0,0}, {}, {16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16}}},
							{solid = true, angle = 0.7, heightmap = {{0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6}, {16,16,16,16,16,16,0,0,0,0,0,0,0,0,0,0}, {}, {6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0}}},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
--
							{solid = true, angle = 0, heightmap = {{16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16}, {16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16}, {}, {16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16}}},
							{solid = false},
							{solid = true, angle = 0.7, heightmap = {{7,8,9,10,11,12,13,14,15,16,16,16,16,16,16,16}, {16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16}, {}, {16,16,16,16,16,16,16,15,14,13,12,11,10,9,8,7}}},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
--
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
--
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
--
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
--
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false},
							{solid = false}
}


-- Properties
go.property("sanic_state",0)
go.property("ground_mode",0)
go.property("flipped",false)
go.property("ducking",false)
go.property("looking_up",false)
go.property("rolling",true)
go.property("gsp",0)
go.property("xsp",0)
go.property("ysp",0)


function init(self)
	msg.post(".", "acquire_input_focus")
	
	self.sanic_state = mod_sanic_state.SANIC_STATE_AIR
	self.ground_mode = mod_ground_mode.SANIC_GROUND_MODE_OVER
	self.on_ground = nil
	
	-- Initialise Input Variables
	blank_inputs(self)
	
	-- Add initialization code here
	-- Remove this function if not needed
end



function final(self)
	msg.post(".", "release_input_focus")
	
	-- Add finalization code here
	-- Remove this function if not needed
end



function update(self, dt)
	if self.sanic_state == mod_sanic_state.SANIC_STATE_GROUND then
		update_ground(self, dt)
	elseif self.sanic_state == mod_sanic_state.SANIC_STATE_AIR then
		update_air(self, dt)
	end
	
	-- Move GO by xsp and ysp
	local pos = go.get_position()
	pos = pos + vmath.vector3(self.xsp, self.ysp, 0)
	go.set_position(pos)
	
	-- Stop at walls, floors, etc
	check_terrain(self, dt)
	
	if self.sanic_state == mod_sanic_state.SANIC_STATE_GROUND then
		update_ground_post(self, dt)
	elseif self.sanic_state == mod_sanic_state.SANIC_STATE_AIR then
		update_air_post(self, dt)	
	end
	
	-- Visual updates
	set_sprite_angle(self)
	
	-- Blank inputs
	blank_inputs(self)
end



function blank_inputs(self)
	self.input_lr = 0
	self.input_down = false
	self.input_up = false
	self.input_jump = false
	self.input_jump_pressed = false
end



function update_ground(self, dt)
	
	--print("update_ground")
	
	-- Don't allow movement if ducking or looking up
	if self.ducking ~= true and self.looking_up ~= true then
		if self.input_lr ~= 0 then
			-- TODO: Deceleration and rolling friction

			-- Apply input to Ground Speed
			self.gsp = self.gsp + (ACCEL_GROUND * dt * self.input_lr)
		else
			-- Apply friction and deceleration
			apply_friction(self, dt)
		end
	end
	
	-- Limit top speed
	apply_top_speed(self)
	
	-- Apply Ground Speed to X and Y Speed
	apply_ground_speed(self)	
	
	-- Apply gravity
	apply_gravity(self, dt)
	
	-- Attempt jump
	if self.input_jump_pressed == true then
		self.sanic_state = mod_sanic_state.SANIC_STATE_AIR
		self.rolling = true
		
		local ground_angle = get_ground_angle(self)
		self.xsp = self.xsp + JUMP_INITIAL_SPEED * -math.sin(ground_angle)
		self.ysp = self.ysp + JUMP_INITIAL_SPEED * math.cos(ground_angle)
		
		self.gsp = 0	
	end
	
	-- Allow ducking or rolling
	self.ducking = false
	self.looking_up = false
	if self.input_down == true then
		if self.gsp == 0 then
			-- Duck
			self.ducking = true
		elseif math.abs(self.gsp) >= MIN_ROLLING_GSP then
			-- Roll	
			self.rolling = true
		end
	-- Allow looking up
	elseif self.input_up == true then
		if self.gsp == 0 then
			-- Look up
			self.looking_up = true
		end
	end
		
end



function update_ground_post(self, dt)
	-- check if we should switch to air mode
	if self.on_ground == nil then
		self.sanic_state = mod_sanic_state.SANIC_STATE_AIR	
	end
	
	-- Stop rolling if we stop moving
	if self.gsp == 0 then
		self.rolling = false
	end
	
	-- Set flipped status based upon gsp
	if self.gsp > 0 then
		self.flipped = false
	elseif self.gsp < 0 then
		self.flipped = true
	end
end



function update_air(self, dt)
	--print("update_air")
	-- Apply input to Air Speed
	self.xsp = self.xsp + (ACCEL_AIR * dt * self.input_lr)
	
	-- Apply gravity	
	apply_gravity(self, dt)
	
	self.ysp = math.min(self.ysp, TOP_SPEED_AIR_Y)
	self.ysp = math.max(self.ysp, -TOP_SPEED_AIR_Y)
	
	-- Land?
end


function update_air_post(self, dt)
	-- Check if we should land
	if self.on_ground and self.on_ground.touched then
		self.sanic_state = mod_sanic_state.SANIC_STATE_GROUND	
		self.rolling = self.input_down
		
		self.gsp = self.xsp
		self.xsp = 0
		self.ysp = 0
		print("landed")
	end
end



function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end



function on_input(self, action_id, action)
	
	-- Take input for left/right movement
	if action_id == hash("move_left") then
		self.input_lr = self.input_lr - 1
	end
	if action_id == hash("move_right") then
		self.input_lr = self.input_lr + 1
	end
	
	-- Take input for down/duck/roll
	if action_id == hash("action_down") then
		self.input_down = true
	end
	
	-- Take input for up/look up
	if action_id == hash("action_up") then
		self.input_up = true
	end
	
	if action_id == hash("action_jump") then
		self.input_jump = true
		if action.pressed then
			self.input_jump_pressed = true
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end



function apply_gravity(self, dt)
	self.ysp = self.ysp + GRAVITY_AIR
end



function apply_friction(self, dt)
	local accel_this_frame = FRICTION_GROUND_RUN * dt
	if math.abs(self.gsp) <= accel_this_frame then
		-- Stop
		self.gsp = 0
	else
		-- Deduct friction value from ground speed	
		local sign = 1
		if self.gsp < 0 then
			sign = -1	
		end
		
		self.gsp = self.gsp - (sign * accel_this_frame)	
	end
end



function apply_top_speed(self)
	self.gsp = math.min(self.gsp, TOP_SPEED_GROUND_RUN)
	self.gsp = math.max(self.gsp, -TOP_SPEED_GROUND_RUN)	
end



function apply_ground_speed(self)
	-- Get ground angle and use it to convert ground speed to x and y speed
	local ground_angle = get_ground_angle(self)
	self.xsp = self.gsp * math.cos(ground_angle)
	self.ysp = self.gsp * math.sin(ground_angle)
	--print("Applying ground speed results, x:\t", self.xsp, "\ty:zt", self.ysp)
end



function get_ground_angle(self)
	if self.on_ground and self.on_ground.touched then
		return TILE_DATA[self.on_ground.tile].angle
	else
		return 0
	end
end



function check_terrain(self)
	self.on_ground = nil
	
	-- WALLS	
	local my_pos = go.get_position()
	local wall_sensors = {}
	for i, v in pairs(mod_sensor_helper.SENSOR_COLLECTION_WALL) do
		-- Make a copy of the standard sensor data because we intend to modify it
		local new_sensor = mod_sensor_helper.copy_sensor_data(v)
		-- Rotate the sensor offset to match our ground mode
		mod_sensor_helper.orient_sensor_offset(new_sensor, self.ground_mode)
		-- Offset the sensor position by our world position
		mod_sensor_helper.set_sensor_pos(new_sensor, my_pos)
		-- Add to our array
		table.insert(wall_sensors, new_sensor)
	end

		
	-- Check each sensor in turn to see if it penetrates a wall, then move the game object till that sensor no longer does so
	for i, v in pairs(wall_sensors) do
		while true do
			local ground_touched = get_ground_under_sensor(self, v)			
			if ground_touched ~= nil and ground_touched.touched then
				
				-- Stop ground or x movement
				self.xsp = 0
				self.gsp = 0
				
				-- Move away from the wall
				local pos  = go.get_position()
			
				local ground_touched_up = mod_ground_mode.SANIC_GM_UP[ground_touched.sensor.ground_mode]
			
				local correction = (ground_touched.penetration) * ground_touched_up
				
				pos = pos + correction
				go.set_position(pos)
				
				for i, v in pairs(wall_sensors) do
					mod_sensor_helper.offset_sensor_pos(v, correction)
				end
			else
				break
			end
		end
	end
	
	-- FLOOR
	local left_bottom_ground = nil
	local right_bottom_ground = nil
	
	local done = false
	while done == false do
		--local left_bottom_ground = get_ground_under_sensor(self, mod_sensor_helper.SENSOR_LEFT_BOTTOM, mod_ground_mode.SANIC_GROUND_MODE_OVER)
		--local right_bottom_ground = get_ground_under_sensor(self, mod_sensor_helper.SENSOR_RIGHT_BOTTOM, mod_ground_mode.SANIC_GROUND_MODE_OVER)
	
	
		-- TODO: Create these once and offset their position as we move the character
		local my_pos = go.get_position()
		local ground_sensors = {}
		for i, v in pairs(mod_sensor_helper.SENSOR_COLLECTION_GROUND) do
			-- Make a copy of the standard sensor data because we intend to modify it
			local new_sensor = mod_sensor_helper.copy_sensor_data(v)
			-- Rotate the sensor offset to match our ground mode
			mod_sensor_helper.orient_sensor_offset(new_sensor, self.ground_mode)	
			-- Offset the sensor position by our world position
			mod_sensor_helper.set_sensor_pos(new_sensor, my_pos)
			-- Add to our array
			table.insert(ground_sensors, new_sensor)
		end
		
		
		-- Find the highest of the ground sensors at our current position
		local highest_touched = nil
		for i, v in pairs(ground_sensors) do
			local ground_touched = get_ground_under_sensor(self, v)
			if ground_touched ~= nil and ground_touched.touched then
				if highest_touched == nil or ground_touched.penetration > highest_touched.penetration then
					highest_touched = ground_touched	
				end
			end
		end
		
		if highest_touched ~= nil then
			
			-- Move away from penetration
			local pos  = go.get_position()
			
			local highest_touched_up = mod_ground_mode.SANIC_GM_UP[highest_touched.sensor.ground_mode]
			
			pos = pos + ((highest_touched.penetration) * highest_touched_up)
			go.set_position(pos)
			
			self.on_ground = highest_touched
		else
			done = true
		end
	end
end	



function get_ground_under_sensor(self, sensor_data)

	-- Set up the return struct
	local ret = {solid = false, touched = false, penetration = 0, tile = nil, sensor = mod_sensor_helper.copy_sensor_data(sensor_data)}
	
	local sensor_tile_pos = world_to_tile_pos(sensor_data.pos)
	local sensor_sub_tile_pos = sensor_data.pos-(sensor_tile_pos*mod_tile_helper.TILE_SIZE)
	
	-- Get the tile type under the sensor
	local sensor_tile = tilemap.get_tile(TILEMAP_URL,"fore",sensor_tile_pos.x+1,sensor_tile_pos.y+1)
	
	if sensor_tile then
		
		-- Get data associated with the tile type and check that it is solid
		local sensor_tile_data = TILE_DATA[sensor_tile]
		
		if sensor_tile_data and sensor_tile_data.solid == true then
			
			-- Get the heightmap used for this sensor
			-- TODO: This won't work when we start walking on walls and stuff, because we haven't combined the character ground mode with the sensor's
			local heightmap = sensor_tile_data.heightmap[sensor_data.ground_mode]
			
			local heightmap_coords = mod_ground_mode.separate_heightmap_coords(sensor_sub_tile_pos, sensor_data.ground_mode)
			local heightmap_index = math.floor(heightmap_coords.offset)+1
			
			local heightmap_value_at_offset = heightmap[heightmap_index]

			-- Always return tile data for solid tiles
			ret.solid = true
			
			ret.penetration = heightmap_value_at_offset - heightmap_coords.height
			ret.touched = ret.penetration > 0
			ret.tile = sensor_tile
			
		end
	end
	
	return ret
end



function world_to_tile_pos(world_pos)
	return vmath.vector3(math.floor(world_pos.x/mod_tile_helper.TILE_SIZE), math.floor(world_pos.y/mod_tile_helper.TILE_SIZE), 0)	
end



function get_sub_tile_height(tile_relative_pos, tile_data)
	if tile_data.solid == false then
		return 0
	end
	
	return tile_data.heightmap[mod_ground_mode.SANIC_GROUND_MODE_OVER][math.floor(tile_relative_pos.x)]
end



-- Returns the ground mode corresponding to a given angle of ground
function get_ground_mode_for_angle(angle)
	local segment_size = math.pi*2/4
	local offset_angle = angle+(segment_size*0.5)
	local segment = math.fmod(math.floor(offset_angle/segment_size), 4)+1
	return segment
end



-- Returns the angle reduced to the nearest equal rotational division based on the number of rotated sprites
function get_sprite_angle_for_angle(angle)
	local offset_angle = angle +(RAD_2_SPRITE_ANGLE*0.5)

	return RAD_2_SPRITE_ANGLE * math.floor(SPRITE_ANGLE_2_RAD * offset_angle)
end



-- Set the game object rotation
function set_sprite_angle(self)
	if self.on_ground then
		local tile_data = TILE_DATA[self.on_ground.tile]
		
		local angle = get_sprite_angle_for_angle(tile_data.angle)	
		
		go.set_rotation(vmath.quat_rotation_z(angle))
	end
end


